# SPECInt2006-micro 상세 기술 문서

## 개요

SPECInt2006-micro는 SPEC CPU2006 정수 벤치마크 스위트의 핵심 연산 패턴을 추출하여 마이크로 벤치마크로 구현한 것입니다. 원본 벤치마크가 수십억 사이클의 실행 시간이 필요한 반면, 이 마이크로 커널들은 수만~수백만 사이클 수준으로 실행되어 CPU 마이크로아키텍처 분석에 적합합니다.

### 목적

- **CPU 병목 분석**: 특정 연산 패턴에서의 CPU 성능 병목 식별
- **마이크로아키텍처 검증**: 분기 예측, 캐시, 파이프라인 등의 동작 검증
- **빠른 반복 테스트**: RTL 시뮬레이션에서 합리적인 시간 내 실행 가능
- **베어메탈 실행**: OS 없이 직접 하드웨어에서 실행 가능

---

## 벤치마크 매핑

| SPECInt2006 | 마이크로 커널 | 핵심 패턴 |
|-------------|--------------|----------|
| 400.perlbench | hash_lookup, string_match, regex_compile | 해시 테이블, 문자열 처리, NFA 구축 |
| 401.bzip2 | bwt_sort, huffman_tree, mtf_transform | 압축 알고리즘, 힙 연산, 순차 변환 |
| 403.gcc | tree_walk, ssa_dataflow | AST 순회, 제어 흐름 그래프, 데이터플로우 분석 |
| 429.mcf | graph_simplex | 네트워크 심플렉스, 포인터 체이싱 |
| 445.gobmk | go_liberty, influence_field | 그래프 순회, 영역 확산 |
| 456.hmmer | viterbi_hmm, forward_backward | 동적 프로그래밍, HMM 알고리즘 |
| 458.sjeng | game_tree | 알파-베타 탐색, 트랜스포지션 테이블 |
| 462.libquantum | quantum_sim | 양자 게이트 시뮬레이션, 복소수 연산 |
| 464.h264ref | dct_4x4, block_sad, intra_predict | 블록 변환, 움직임 추정, 인트라 예측 |
| 471.omnetpp | priority_queue | 우선순위 큐, 이벤트 시뮬레이션 |
| 473.astar | astar_path | A* 경로 탐색, 휴리스틱 탐색 |
| 483.xalancbmk | xpath_eval | DOM 트리 순회, XPath 쿼리 평가 |

---

## 원본 SPECInt2006과의 차이점

### 1. 규모의 차이

| 항목 | 원본 SPECInt2006 | SPECInt2006-micro |
|------|-----------------|-------------------|
| 실행 시간 | 수백억~수천억 사이클 | 수만~수백만 사이클 |
| 데이터 크기 | GB 단위 | KB~MB 단위 |
| 코드 크기 | 수십만~수백만 라인 | 수백~수천 라인 |
| 입력 데이터 | 실제 워크로드 | 합성 데이터 |

### 2. 추상화 수준

- **원본**: 완전한 애플리케이션 (컴파일러, 압축 프로그램, AI 등)
- **마이크로**: 핵심 알고리즘 루프만 추출

### 3. 플랫폼 지원

- **원본**: POSIX 환경, 파일 시스템, 동적 메모리 할당 필요
- **마이크로**: 베어메탈 환경, 정적 메모리, OS 불필요

### 4. 캐시/메모리 동작

- **원본**: 대규모 작업 세트로 캐시 스트레스 높음
- **마이크로**: 작은 작업 세트, L1/L2 캐시에 대부분 적중

### 5. 대표성

마이크로 커널은 원본의 핵심 핫스팟을 포착하지만, 완전한 애플리케이션 동작 (초기화, I/O, 에러 처리 등)은 포함하지 않습니다.

---

## 커널 상세 분석

### 400.perlbench 계열

#### hash_lookup
```
소스: src/hash_lookup.c
패턴: 체인 해시 테이블 조회
원본 대응: Perl의 해시 변수 (HV) 구현
```

**알고리즘 설명**:
- DJB2 해시 함수를 사용한 체인 해시 테이블
- 75% 히트율, 25% 미스율의 조회 패턴
- 버킷 체인을 따라가는 포인터 체이싱

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **메모리 지연** | 체인 포인터 체이싱으로 인한 종속적 로드 |
| **분기 예측** | 해시 충돌 처리의 데이터 의존적 분기 |
| **캐시 미스** | 불규칙한 메모리 접근 패턴 |

**확인 가능한 패턴**:
- 포인터 체이싱 성능
- 데이터 의존적 분기 예측 정확도
- 해시 테이블 지역성

---

#### string_match
```
소스: src/string_match.c
패턴: KMP 및 Boyer-Moore-Horspool 문자열 검색
원본 대응: Perl 정규표현식 매칭
```

**알고리즘 설명**:
- KMP (Knuth-Morris-Pratt) 알고리즘: 실패 함수 기반 백트래킹
- BMH (Boyer-Moore-Horspool) 알고리즘: Bad character 테이블 기반 스킵

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **순차 메모리 접근** | 텍스트 스캔의 순차적 특성 |
| **분기 예측** | 패턴 매치/불일치의 데이터 의존적 분기 |
| **테이블 조회** | BMH 스킵 테이블 (256 엔트리) |

**확인 가능한 패턴**:
- 순차 메모리 대역폭
- 작은 테이블의 캐시 적중률
- 문자열 비교의 분기 예측

---

#### regex_compile
```
소스: src/regex_compile.c
패턴: Thompson의 NFA 구축
원본 대응: Perl 정규표현식 컴파일
```

**알고리즘 설명**:
- 정규표현식을 NFA (Non-deterministic Finite Automaton)로 변환
- 상태와 전이 테이블 구축
- 문자 클래스, 양자화 연산자 지원

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **제어 흐름 복잡도** | switch 문의 다중 분기 |
| **동적 구조 구축** | 상태/전이 배열의 순차적 추가 |
| **재귀적 처리** | 중첩 패턴의 스택 사용 |

---

### 401.bzip2 계열

#### bwt_sort
```
소스: src/bwt_sort.c
패턴: Burrows-Wheeler 변환
원본 대응: bzip2 블록 정렬 압축
```

**알고리즘 설명**:
- Radix 정렬 (첫 바이트) + 3-way Quicksort (나머지)
- 접미사 배열 정렬을 통한 BWT 수행
- 원본 위치 추적

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **비교 연산** | 접미사 비교의 다중 메모리 접근 |
| **분기 예측** | Quicksort의 피벗 비교 |
| **메모리 대역폭** | 정렬 중 데이터 이동 |
| **캐시 오염** | Radix 분배 시 산발적 쓰기 |

**확인 가능한 패턴**:
- 정렬 알고리즘 성능
- 스트라이드 접근 패턴
- 분기 예측 정확도

---

#### huffman_tree
```
소스: src/huffman_tree.c
패턴: 허프만 트리 구축
원본 대응: bzip2 엔트로피 코딩
```

**알고리즘 설명**:
- 이진 최소 힙을 이용한 허프만 트리 구축
- 빈도 기반 심볼 결합
- 코드 길이 계산 및 제한 (최대 20비트)

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **힙 연산** | bubble-up/bubble-down의 반복적 비교 |
| **데이터 의존 분기** | 힙 속성 유지를 위한 조건 분기 |
| **포인터 기반 순회** | DFS 트리 순회 (코드 길이 계산) |

**확인 가능한 패턴**:
- 힙 자료구조 성능
- 트리 순회 패턴
- 반복적 조건 분기 예측

---

#### mtf_transform
```
소스: src/mtf_transform.c
패턴: Move-To-Front 변환
원본 대응: bzip2 MTF 엔코딩
```

**알고리즘 설명**:
- 심볼을 리스트에서 찾아 인덱스 출력
- 찾은 심볼을 리스트 맨 앞으로 이동
- 반복적 심볼에 대해 낮은 인덱스 생성

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **선형 검색** | 리스트에서 심볼 검색 (최대 256회 비교) |
| **데이터 이동** | 심볼을 앞으로 이동하기 위한 메모리 복사 |
| **데이터 의존 루프** | 검색 위치에 따른 가변 반복 횟수 |

**확인 가능한 패턴**:
- 선형 검색 최적화
- 데이터 의존 루프의 분기 예측
- 연속 메모리 복사 성능

---

### 403.gcc 계열

#### tree_walk
```
소스: src/tree_walk.c
패턴: AST (Abstract Syntax Tree) 순회
원본 대응: GCC의 중간 표현 처리
```

**알고리즘 설명**:
- 재귀적 트리 순회 (전위/후위)
- 상수 접기 (constant folding) 최적화
- 표현식 평가

**노드 타입**: INTEGER, PLUS, MINUS, MULT, DIV, VAR, IF, BLOCK

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **재귀 호출** | 깊은 호출 스택, 반환 주소 예측 |
| **간접 분기** | 노드 타입에 따른 switch 분기 |
| **포인터 체이싱** | 트리 노드 간 포인터 따라가기 |
| **불규칙 접근** | 트리 구조의 비순차적 메모리 접근 |

**확인 가능한 패턴**:
- 재귀 함수 호출 오버헤드
- 간접 분기 예측 정확도
- 불규칙 포인터 체이싱 성능

---

#### ssa_dataflow
```
소스: src/ssa_dataflow.c
패턴: SSA 형식 및 데이터플로우 분석
원본 대응: GCC의 최적화 패스
```

**알고리즘 설명**:
- Cooper-Harvey-Kennedy 지배자 계산 알고리즘
- 지배 프론티어 계산
- Phi 함수 배치
- 라이브니스 분석 (후진 데이터플로우)

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **비트 연산** | 비트마스크 기반 집합 연산 (64비트) |
| **반복 알고리즘** | 고정점 도달까지 반복 |
| **그래프 순회** | CFG의 전진/후진 순회 |
| **데이터 의존성** | 이전 반복 결과에 의존 |

**확인 가능한 패턴**:
- 비트 연산 성능
- 수렴 알고리즘의 분기 예측
- 워크리스트 기반 알고리즘

---

### 429.mcf 계열

#### graph_simplex
```
소스: src/graph_simplex.c
패턴: 네트워크 심플렉스 알고리즘
원본 대응: MCF (Minimum Cost Flow) 최적화
```

**알고리즘 설명**:
- 프라이멀 심플렉스: entering arc 선택 (pricing)
- 비율 테스트: leaving arc 결정
- 트리 구조 업데이트
- 포텐셜 업데이트 (BFS)

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **극심한 포인터 체이싱** | node->arc->node 체인 |
| **높은 캐시 미스율** | 불규칙한 그래프 접근 |
| **데이터 의존 분기** | reduced cost 비교 |
| **낮은 ILP** | 종속적 연산 체인 |

**확인 가능한 패턴**:
- 포인터 집약적 워크로드
- 메모리 지연 숨기기 능력
- 프리페칭 효과

> **참고**: 429.mcf는 SPECInt2006에서 가장 메모리 집약적인 벤치마크로 알려져 있습니다.

---

### 445.gobmk 계열

#### go_liberty
```
소스: src/go_liberty.c
패턴: Go 보드 자유도 계산
원본 대응: GNU Go AI의 보드 평가
```

**알고리즘 설명**:
- Flood-fill 기반 연결 그룹 탐지
- BFS 기반 자유도 (liberties) 계산
- 포위 가능성 분석
- 영향력 평가 (거리 가중치)

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **2D 그리드 순회** | 보드의 4방향/8방향 이웃 접근 |
| **조건부 확장** | 돌 색상에 따른 탐색 방향 결정 |
| **visited 배열** | 반복 방문 방지를 위한 마킹 |

**확인 가능한 패턴**:
- 2D 배열 접근 패턴
- BFS/DFS 탐색 성능
- 조건부 분기 예측

---

#### influence_field
```
소스: src/influence_field.c
패턴: Bouzy의 영향력 전파 알고리즘
원본 대응: GNU Go의 세력 평가
```

**알고리즘 설명**:
- 돌 위치에서 영향력 초기화 (±64)
- Dilation: 이웃으로 영향력 확산
- Erosion: 고립된 영향력 제거
- Moyo (잠재적 영역) 계산

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **규칙적 그리드 접근** | 19x19 보드의 순차 스캔 |
| **스텐실 연산** | 4-이웃 기반 갱신 |
| **다중 패스** | dilation/erosion 반복 |

**확인 가능한 패턴**:
- 스텐실 연산 성능
- 캐시 라인 활용률
- 반복적 그리드 갱신

---

### 456.hmmer 계열

#### viterbi_hmm
```
소스: src/viterbi_hmm.c
패턴: Viterbi 동적 프로그래밍
원본 대응: HMMER의 HMM 시퀀스 정렬
```

**알고리즘 설명**:
- Plan7 HMM 모델 (Match, Insert, Delete 상태)
- 2D DP 행렬: seq_length × model_size
- max3() 연산으로 최적 경로 선택

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **행 단위 메모리 접근** | 이전 행에서 현재 행으로 순차적 갱신 |
| **max 연산** | 3-way 비교의 조건 분기 |
| **테이블 조회** | emission/transition 확률 테이블 |
| **높은 연산 밀도** | 각 셀에서 다중 덧셈/비교 |

**확인 가능한 패턴**:
- 2D DP 알고리즘 성능
- SIMD 병렬화 가능성
- 행 버퍼 캐시 활용

---

#### forward_backward
```
소스: src/forward_backward.c
패턴: Forward-Backward HMM 알고리즘
원본 대응: HMMER의 확률적 정렬
```

**알고리즘 설명**:
- Forward: 시작에서 끝까지 확률 누적
- Backward: 끝에서 시작까지 확률 누적
- Posterior: 각 위치의 상태 확률 계산
- Log-space 연산 (수치 안정성)

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **log-sum-exp 연산** | log_add()의 조건부 연산 |
| **전진/후진 의존성** | 행렬 전체에 대한 2-pass 알고리즘 |
| **메모리 사용량** | seq_len × num_states × 3 행렬 |

---

### 458.sjeng 계열

#### game_tree
```
소스: src/game_tree.c
패턴: Alpha-Beta 탐색
원본 대응: Sjeng 체스 엔진의 탐색
```

**알고리즘 설명**:
- Negamax 기반 알파-베타 가지치기
- 트랜스포지션 테이블 (Zobrist 해싱)
- Killer moves 휴리스틱 (이동 순서 최적화)
- 반복 심화 탐색

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **높은 분기 비예측성** | 게임 상태에 따른 극도로 불규칙한 분기 |
| **깊은 재귀** | 탐색 깊이만큼의 호출 스택 |
| **해시 테이블 접근** | 트랜스포지션 테이블 조회 |
| **이동 생성/정렬** | 의사 합법 이동 생성 및 순서화 |

**확인 가능한 패턴**:
- 분기 예측 실패율 (매우 높음)
- 재귀 호출 오버헤드
- 해시 테이블 캐시 동작

> **참고**: 458.sjeng은 SPECInt2006에서 분기 예측이 가장 어려운 벤치마크입니다.

---

### 462.libquantum 계열

#### quantum_sim
```
소스: src/quantum_sim.c
패턴: 양자 게이트 시뮬레이션
원본 대응: Shor의 소인수분해 알고리즘
```

**알고리즘 설명**:
- 상태 벡터 표현 (2^n 복소수 진폭)
- 양자 게이트: Hadamard, Pauli-X/Z, CNOT, Toffoli
- QFT (Quantum Fourier Transform)
- 고정소수점 복소수 연산 (FP 없는 환경용)

**양자 게이트 동작**:
| 게이트 | 연산 | 복잡도 |
|--------|------|--------|
| Hadamard | 중첩 생성 | O(2^n) |
| Pauli-X | 비트 플립 | O(2^n) |
| CNOT | 조건부 플립 | O(2^n) |
| Toffoli | 2-조건부 플립 | O(2^n) |

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **복소수 연산** | 64비트 곱셈/덧셈 |
| **상태 벡터 순회** | 전체 진폭 배열 스캔 |
| **비트 마스킹** | 큐비트 인덱스 계산 |
| **메모리 대역폭** | 대규모 상태 벡터 접근 |

**확인 가능한 패턴**:
- 복소수 산술 성능
- 선형 메모리 스캔
- 비트 연산 효율성

---

### 464.h264ref 계열

#### dct_4x4
```
소스: src/dct_4x4.c
패턴: H.264 정수 4x4 DCT
원본 대응: H.264 변환 코딩
```

**알고리즘 설명**:
- H.264 규격의 정수 DCT (부동소수점 없음)
- 수평/수직 2-pass 변환
- 양자화 및 역양자화
- 역변환 (IDCT)

**변환 행렬**:
```
     | 1  1  1  1 |
 C = | 2  1 -1 -2 |
     | 1 -1 -1  1 |
     | 1 -2  2 -1 |
```

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **규칙적 계산** | 고정 크기 블록의 예측 가능한 연산 |
| **높은 ILP** | 독립적인 행/열 연산 |
| **SIMD 최적화 가능** | 4-wide 병렬 처리 |
| **작은 작업 세트** | 4x4 블록이 레지스터에 적합 |

**확인 가능한 패턴**:
- 정수 연산 처리량
- SIMD 활용 가능성
- 레지스터 압력

---

#### block_sad
```
소스: src/block_sad.c
패턴: 움직임 추정 SAD (Sum of Absolute Differences)
원본 대응: H.264 모션 추정
```

**알고리즘 설명**:
- 16x16 매크로블록 SAD 계산
- 다이아몬드 탐색 패턴
- 전역 탐색 (±8 픽셀 범위)
- 최소 SAD 위치 = 모션 벡터

**탐색 패턴**:
```
    *
  * * *
    *
(다이아몬드)
```

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **절대값 연산** | 차이 계산 후 abs() |
| **2D 블록 접근** | 16x16 블록의 순차 스캔 |
| **탐색 윈도우** | 여러 참조 위치 비교 |
| **SIMD 최적화 가능** | SAD는 대표적 SIMD 연산 |

**확인 가능한 패턴**:
- 미디어 처리 성능
- 2D 메모리 접근 패턴
- 비교/축소 연산

---

#### intra_predict
```
소스: src/intra_predict.c
패턴: H.264 인트라 예측
원본 대응: H.264 공간적 예측
```

**알고리즘 설명**:
- 4x4 블록: 9가지 예측 모드 (Vertical, Horizontal, DC, 대각선 등)
- 16x16 블록: 4가지 예측 모드 (Vertical, Horizontal, DC, Plane)
- 이웃 픽셀 참조 (상단, 좌측)
- 최적 모드 선택 (SAD 최소화)

**4x4 인트라 모드**:
| 모드 | 방향 | 설명 |
|------|------|------|
| 0 | Vertical | 상단 픽셀 복사 |
| 1 | Horizontal | 좌측 픽셀 복사 |
| 2 | DC | 이웃 평균 |
| 3 | Diagonal Down-Left | 좌하향 대각선 |
| 4 | Diagonal Down-Right | 우하향 대각선 |
| 5-8 | Vertical/Horizontal 변형 | 각도 변형 |

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **모드별 분기** | 9개 예측 모드 switch |
| **참조 픽셀 접근** | 상단/좌측 이웃 페치 |
| **모드 결정** | 모든 모드 시도 후 최소 SAD 선택 |

---

### 471.omnetpp 계열

#### priority_queue
```
소스: src/priority_queue.c
패턴: 이벤트 스케줄링 우선순위 큐
원본 대응: OMNeT++ 이산 이벤트 시뮬레이터
```

**알고리즘 설명**:
- 이진 최소 힙 기반 우선순위 큐
- 이벤트: timestamp, event_id, module_id, priority
- Insert: O(log n), Extract: O(log n)
- 이벤트 취소 지원

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **힙 버블링** | bubble-up/bubble-down의 비교 연산 |
| **데이터 의존 분기** | 힙 속성 비교 |
| **캐시 접근 패턴** | 부모/자식 인덱스 간 점프 |
| **객체 복사** | 이벤트 구조체 이동 |

**확인 가능한 패턴**:
- 힙 자료구조 성능
- 로그 복잡도 연산
- 시뮬레이션 워크로드 특성

---

### 473.astar 계열

#### astar_path
```
소스: src/astar_path.c
패턴: A* 경로 탐색
원본 대응: 게임 AI 경로 탐색
```

**알고리즘 설명**:
- A* 탐색: f(n) = g(n) + h(n)
- g(n): 시작점에서의 실제 비용
- h(n): 목표까지의 휴리스틱 (대각선 거리)
- 8방향 이동 (직선: 10, 대각선: 14)
- 장애물 회피

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **우선순위 큐** | f값 기반 open set 관리 |
| **그리드 접근** | 2D 맵의 이웃 셀 접근 |
| **휴리스틱 계산** | abs 연산 및 min/max |
| **visited 체크** | 닫힌 집합 확인 |

**확인 가능한 패턴**:
- 휴리스틱 탐색 알고리즘
- 그리드 기반 경로 탐색
- 우선순위 큐 성능

---

### 483.xalancbmk 계열

#### xpath_eval
```
소스: src/xpath_eval.c
패턴: XPath 쿼리 평가
원본 대응: XSLT 변환의 DOM 처리
```

**알고리즘 설명**:
- DOM 트리 생성 (Element, Text, Attribute 노드)
- XPath 축 순회: child, descendant, parent, ancestor, sibling
- 노드 테스트 (이름 매칭)
- 술어 평가 (위치, 속성 값)

**XPath 축**:
| 축 | 탐색 방향 |
|----|----------|
| child | 직접 자식 |
| descendant | 모든 후손 |
| parent | 직접 부모 |
| ancestor | 모든 조상 |
| following-sibling | 이후 형제 |
| preceding-sibling | 이전 형제 |

**마이크로아키텍처 병목**:
| 병목 유형 | 설명 |
|----------|------|
| **포인터 체이싱** | 부모/자식/형제 포인터 |
| **문자열 비교** | 노드 이름 매칭 |
| **재귀 순회** | descendant/ancestor 축 |
| **동적 결과 집합** | 쿼리 결과 노드 수집 |

**확인 가능한 패턴**:
- DOM 트리 순회 성능
- 문자열 매칭
- 재귀적 탐색

---

## CPU 병목 분석 가이드

### 병목 유형별 관련 커널

#### 1. 분기 예측 (Branch Prediction)

| 난이도 | 커널 | 특징 |
|--------|------|------|
| **매우 어려움** | game_tree | 게임 상태 의존적 극도로 불규칙한 분기 |
| **어려움** | hash_lookup, graph_simplex | 데이터 의존 포인터 체이싱 |
| **중간** | bwt_sort, huffman_tree | 정렬/힙의 비교 분기 |
| **쉬움** | dct_4x4, block_sad | 고정 크기 루프 |

#### 2. 캐시 성능 (Cache)

| 특성 | 커널 | 접근 패턴 |
|------|------|----------|
| **높은 미스율** | graph_simplex, hash_lookup | 불규칙 포인터 체이싱 |
| **스트라이드 접근** | bwt_sort, viterbi_hmm | 규칙적 오프셋 |
| **순차 스캔** | string_match, quantum_sim | 선형 배열 순회 |
| **2D 그리드** | block_sad, influence_field | 행/열 우선 접근 |

#### 3. 명령어 수준 병렬성 (ILP)

| 수준 | 커널 | 특징 |
|------|------|------|
| **높은 ILP** | dct_4x4, quantum_sim | 독립적 연산 다수 |
| **중간 ILP** | viterbi_hmm, astar_path | 일부 종속성 |
| **낮은 ILP** | graph_simplex, tree_walk | 긴 종속 체인 |

#### 4. 메모리 대역폭 (Memory Bandwidth)

| 사용량 | 커널 | 설명 |
|--------|------|------|
| **높음** | mtf_transform, influence_field | 반복적 전체 스캔 |
| **중간** | block_sad, forward_backward | 블록/행렬 처리 |
| **낮음** | game_tree, xpath_eval | 산발적 접근 |

---

## 성능 메트릭

### 기준 사이클 (XiangShan RISC-V, ~2GHz 추정)

| 커널 | 평균 사이클 | 카테고리 |
|------|------------|---------|
| game_tree | 32 | 매우 짧음 (재귀 깊이 제한) |
| graph_simplex | 1,200 | 짧음 |
| dct_4x4 | 2,170 | 짧음 |
| xpath_eval | 4,193 | 짧음 |
| hash_lookup | 6,052 | 중간 |
| tree_walk | 13,077 | 중간 |
| viterbi_hmm | 19,606 | 중간 |
| regex_compile | 22,697 | 중간 |
| quantum_sim | 30,481 | 중간 |
| go_liberty | 36,929 | 중간 |
| priority_queue | 40,372 | 중간 |
| string_match | 62,752 | 중간-긴 |
| intra_predict | 194,444 | 긴 |
| ssa_dataflow | 594,075 | 긴 |
| astar_path | 852,946 | 긴 |
| block_sad | 926,751 | 긴 |
| influence_field | 1,251,609 | 매우 긴 |
| forward_backward | 1,478,112 | 매우 긴 |
| mtf_transform | 1,964,800 | 매우 긴 |
| bwt_sort | 17,932 | 중간 |
| huffman_tree | 19,109 | 중간 |

---

## 사용 예시

### ExtPMU와 함께 병목 분석

```c
#include "extpmu.h"

// 카운터 설정
extpmu_enable();
extpmu_reset_counters();

// 특정 커널 실행
kernel_run_func();

// 성능 데이터 수집
extpmu_trigger_snapshot();

uint64_t cycles = extpmu_read_counter(CTR_CYCLES);
uint64_t branch_miss = extpmu_read_counter(CTR_BRANCH_MISPRED);
uint64_t l1d_miss = extpmu_read_counter(CTR_L1D_MISS);

// 분석
double mpki = (double)branch_miss * 1000 / instructions;
printf("Branch MPKI: %.2f\n", mpki);
```

### 커널별 PMU 카운터 권장

| 커널 유형 | 권장 카운터 |
|----------|------------|
| 분기 집약적 | Branch Mispred, BTB Miss |
| 메모리 집약적 | L1D/L2 Miss, Memory Stall |
| 연산 집약적 | IPC, ALU Utilization |
| 혼합 | ROB Stall, Dispatch Stall |

---

## 결론

SPECInt2006-micro는 원본 SPEC CPU2006의 핵심 연산 패턴을 소규모로 재현하여:

1. **빠른 마이크로아키텍처 분석** 가능
2. **특정 병목 식별**에 유용
3. **베어메탈 환경**에서 실행 가능
4. **RTL 시뮬레이션**에 적합한 실행 시간

그러나 원본 벤치마크의 **전체 동작을 완벽히 대체하지는 않으며**, 대규모 작업 세트와 복잡한 제어 흐름은 별도로 평가해야 합니다.
